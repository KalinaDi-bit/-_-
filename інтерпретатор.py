from структури import (
    Функція,
    ВикликФункції,
    Повернути,
    Друк,
    Якщо,
    Присвоєння,
    Поки,
    УнарнаОперація,
)

class Інтерпретатор:
    def __init__(self):
        self.функції = {}
        self.глобальні_змінні = {}

    def виконати(self, програма):
        for елемент in програма:
            if isinstance(елемент, Функція):
                self.функції[елемент.імʼя] = елемент
            else:
                self.виконати_вираз(елемент, локальні=self.глобальні_змінні)

    def виконати_вираз(self, вираз, локальні=None):
        if локальні is None:
            локальні = {}

        if isinstance(вираз, ВикликФункції):
            return self.виконати_виклик_функції(вираз, локальні)

        elif isinstance(вираз, Присвоєння):
            значення = self.отримати_значення(вираз.значення, локальні)
            локальні[вираз.імʼя] = значення
            return None

        elif isinstance(вираз, Повернути):
            return self.отримати_значення(вираз.значення, локальні)

        elif isinstance(вираз, Друк):
            значення = [self.отримати_значення(арг, локальні) for арг in вираз.аргументи]
            print(*значення)
            return None

        elif isinstance(вираз, Поки):
            while self.отримати_значення(вираз.умова, локальні):
                for команда in вираз.тіло:
                    результат = self.виконати_вираз(команда, локальні)
                    if isinstance(результат, Повернути) or результат is not None:
                        return результат
            return None

        elif isinstance(вираз, Якщо):
            умова = self.отримати_значення(вираз.умова, локальні)
            if умова:
                for ком in вираз.тіло:
                    результат = self.виконати_вираз(ком, локальні)
                    if isinstance(результат, Повернути) or результат is not None:
                        return результат
            elif вираз.інакше_тіло:
                if isinstance(вираз.інакше_тіло, Якщо):
                    результат = self.виконати_вираз(вираз.інакше_тіло, локальні)
                    if isinstance(результат, Повернути) or результат is not None:
                        return результат
                else:
                    for ком in вираз.інакше_тіло:
                        результат = self.виконати_вираз(ком, локальні)
                        if isinstance(результат, Повернути) or результат is not None:
                            return результат
            return None

        else:
            return self.отримати_значення(вираз, локальні)

    def виконати_виклик_функції(self, вираз, локальні):
        імʼя = вираз.імʼя
        аргументи = [self.отримати_значення(арг, локальні) for арг in вираз.аргументи]

        if імʼя == 'друкувати':
            print(*аргументи)
            return None

        if імʼя in self.функції:
            функція = self.функції[імʼя]
            return self.виконати_функцію(функція, аргументи)

        raise Exception(f"Невідома функція: {імʼя}")

    def виконати_функцію(self, функція, аргументи):
        if len(аргументи) != len(функція.параметри):
            raise Exception(f"Очікується {len(функція.параметри)} аргумент(ів), отримано {len(аргументи)}")

        локальні_змінні = dict(zip(функція.параметри, аргументи))

        for команда in функція.тіло:
            результат = self.виконати_вираз(команда, локальні_змінні)
            if isinstance(команда, Повернути) or результат is not None:
                return результат
        return None

    def отримати_значення(self, вираз, локальні):
        if isinstance(вираз, ВикликФункції):
            return self.виконати_виклик_функції(вираз, локальні)

        # Обробка обʼєкта унарної операції
        if isinstance(вираз, УнарнаОперація):
            оператор = вираз.оператор
            операнд = self.отримати_значення(вираз.операнд, локальні)
            оператор_тип = оператор[0] if isinstance(оператор, tuple) else оператор

            if оператор_тип == 'МІНУС':
                return -операнд
            if оператор_тип == 'НЕ':
                return not операнд

            raise Exception(f"Невідомий унарний оператор: {оператор_тип}")

        if isinstance(вираз, tuple):
            тип = вираз[0]

            if тип == 'ЧИСЛО':
                значення = вираз[1]
                return float(значення) if '.' in str(значення) else int(значення)

            elif тип == 'РЯДОК':
                return вираз[1]

            elif тип == 'БУЛЕВЕ':
                return bool(вираз[1])

            elif тип == 'ІДЕНТИФІКАТОР':
                імʼя = вираз[1]
                if імʼя in локальні:
                    return локальні[імʼя]
                elif імʼя in self.глобальні_змінні:
                    return self.глобальні_змінні[імʼя]
                else:
                    raise Exception(f"Невідома змінна: {імʼя}")

            elif тип == 'ВИРАЗ':
                _, лівий, оператор, правий = вираз
                л = self.отримати_значення(лівий, локальні)
                п = self.отримати_значення(правий, локальні)

                оператор_тип = оператор[0] if isinstance(оператор, tuple) else оператор

                if оператор_тип == 'ПЛЮС': return л + п
                if оператор_тип == 'МІНУС': return л - п
                if оператор_тип == 'ПРОМІНЕННЯ': return л * п
                if оператор_тип == 'ЦІЛОДІЛЕННЯ': return л // п if п != 0 else self._ділення_на_нуль()
                if оператор_тип == 'ДІЛЕННЯ': return л / п if п != 0 else self._ділення_на_нуль()
                if оператор_тип == 'ЗАЛИШОК': return л % п if п != 0 else self._ділення_на_нуль()

                if оператор_тип == 'РІВНІСТЬ': return л == п
                if оператор_тип == 'НЕ_РІВНІСТЬ': return л != п
                if оператор_тип == 'МЕНШЕ': return л < п
                if оператор_тип == 'БІЛЬШЕ': return л > п
                if оператор_тип == 'МЕНШЕ_АБО_ДОРІВНЮЄ': return л <= п
                if оператор_тип == 'БІЛЬШЕ_АБО_ДОРІВНЮЄ': return л >= п
                if оператор_тип == 'І': return bool(л) and bool(п)
                if оператор_тип == 'АБО': return bool(л) or bool(п)

                raise Exception(f"Невідомий оператор: {оператор_тип}")

            else:
                raise Exception(f"Невідомий тип виразу: {тип}")

        # Якщо це вже значення (int, str, bool)
        return вираз



    def _ділення_на_нуль(self):
        raise Exception("Ділення на нуль!")
